<!DOCTYPE html>
<html lang="en" style="height: 100%;">
<head>
    <meta charset="UTF-8">
    <title>Info Vis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js" integrity="sha512-rKFvwjvE4liWPlFnvH4ZhRDfNZ9FOpdkD/BU5gAIA3VS3vOQrQ5BjKgbO3kxebKhHdHcNUHLqxQYSoxee9UwgA==" crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <script src="echarts.js"></script>
    <style>
        #modal > div {
            background-color: white;
            border: 2px solid black;
            border-radius: 5px;
            padding: 5px;
        }
    </style>
</head>
<body style="padding: 0; height: 100%; width: 100%">

<!-- Instruction button -->
<button style="position: fixed; left: 10px; bottom: 30px; width: 100px; z-index: 9" onclick="$('#modal').fadeIn()">Show instructions</button>

<!-- Reset button -->
<button style="position: fixed; left: 10px; bottom: 10px; width: 100px; z-index: 9" onclick="reset()">Reset view</button>

<!-- Charts -->
<div style="position: relative; height: 100%; width: 100%">
    <div style="height: 100%; width: 50%; position: absolute; top:0; left:0;" id="graph"></div>
    <div id="charts" style="height: 100%; width: 50%; position: absolute; right: 0; top: 0;">
        <div id="link" style="width: 100%; height: 50%;"></div>
        <div id="sentiment" style="width: 100%; height: 50%"></div>
    </div>
</div>

<!-- Legend -->
<div id="legend" style="position: fixed; bottom: 10px; left: 120px; height: 20px; z-index: 9"></div>

<!-- Modal instruction overlay -->
<div id="modal" style="background-color: rgba(0, 0, 0, 0.4); position: fixed; height: 100%; width: 100%; z-index: 10; top: 0; left: 0;">
    <button onclick="$('#modal').fadeOut()" style="width: 100px; height: 20px; position: absolute; top: 50%; left: 50%; margin-top: -10px; margin-left: -50px;">Close instructions</button>
    <div style="position: absolute; left: 20%; top: 40%">
        Click on a node to view it's links to other subreddits.<br>
        Click on an edge to view that edge's average sentiment.<br>
        Hover over a node or edge to highlight connected nodes.<br>
        You can also zoom in and out get a better view.
    </div>
    <div style="position: absolute; right: 20%; top: 20%">
        Once you clicked on a node in the graph, the bar chart here will show<br>
        you the links to other subreddits and the direction of the links.<br>
        Hover over a link to highlight it in the graph. <br>
        Click on a link to show its sentiment below.
    </div>
    <div style="position: absolute; right: 20%; bottom: 20%">
        Once you clicked on an edge in the graph or bar in the link chart above,<br>
        the bar chart here will show you the sentiment of the links coming from one subreddit to another.<br>
        Click on a sentiment to focus the graph on only links coming from the subreddit with the selected sentiment score > 0.<br>
        Click the <i>reset view</i> button on the bottom left to reset the focus.
    </div>
</div>
</body>
<script>
var raw_data = {};
var links = [];
let data = [];
let rows = [];

// List of colors for each sentiment
let sentiment_colors = {
    sad: "#0000ff",
    anger: "#ff0000",
    swear: "#ff0066",
    past: "#666699",
    present: "#99ccff",
    future: "#ccffff",
    "positive emotion": "#ccff99",
    "negative emotion": "#ff6666",
    "affection": "#006600",
    social: "#cc9900",
    "non-fluent": "#660066",
    "agreeing": "#663300",
    "disagreeing": "#666633",
}

// Download the CSV file to frontend using papaParse
Papa.parse("/csv.php?lines=2000", {
    download: true,
    header: true,
    step: function (row){
        // Set row ID to cursor number for each row
        row.data['id'] = row.meta.cursor;
        rows.push(row.data);
    },
    complete: function () {
        // Execute when CSV completely loaded
        console.log('CSV completely loaded');

        // Initialize charts
        createGraph();
        createLinkBar();
        createSentimentBar();

        updateGraph();

        // Create the legend using the colors defined above
        for(let sent in sentiment_colors){
            let item = $("<span><span></span><span></span></span>");
            item.css({
                height: "20px",
                margin: "0 5px"
            });
            item.find("span").first().css({
                height: "20px",
                width: "20px",
                backgroundColor: sentiment_colors[sent],
                display: "inline-block",
                marginRight: "5px",
                borderRadius: "5px",
                verticalAlign: "middle"
            });
            item.find("span").last().css({
                verticalAlign: "middle"
            });
            item.find("span").last().text(sent);

            $("#legend").append(item);
        }
    }
});

// Called to reset the multiview
function reset(){
    updateGraph();

    // Remove any data in the link chart
    let linkOption = document.linkChart.getOption();
    linkOption.series[0].data = [];
    linkOption.series[1].data = [];
    document.linkChart.setOption(linkOption);

    // Remove ant data in the sentiment chart
    let sentimentOption = document.sentimentChart.getOption();
    sentimentOption.series[0].data = [];
    document.sentimentChart.setOption(sentimentOption);
}

// Initialize the graph
function createGraph(){
    let options = {
        title: {
            text: "linking subreddits",
        },
        tooltip: {},
        animationDurationUpdate: 1500,
        animationEasingUpdate: 'quinticInOut',
        series: [{
            type: "graph",
            name: "subreddits",
            data: [],
            links: [],
            categories: ["source", "destination"],
            roam: true,
            layout: "force",
            force: {
                repulsion: 1000
            },
            emphasis: {
                focus: 'adjacency',
                label: {
                    position: 'right',
                    show: true
                }
            },
            selectedMode: true
        }]
    }
    document.networkGraph = echarts.init(document.getElementById("graph"))
    document.networkGraph.setOption(options);

    // Add events to the graph
    document.networkGraph.on('click', {dataType: 'node'}, updateLinkBar);
    document.networkGraph.on('click', {dataType: 'edge'}, updateSentimentBar);
}

// Update the data in the graph
function updateGraph(params=null){
    let tbl = [];
    // If no params given, use all the rows in the set
    if(params === null){
        tbl = rows;
    }
    else{
        // Only use the rows with the source node given in params and where its sentiment value is > 0
        let _rows = [];

        for(let row of rows) {
            let source = row["SOURCE_SUBREDDIT"];
            let dest = row["TARGET_SUBREDDIT"];

            if (params.value[2][0] == source && row['LIWC_' + params.value[0]] > 0) {
                _rows.push(row);
            }
        }
        tbl = _rows;
    }

    let data = [];
    let links = [];
    let raw_data = {};

    // Create the datastructure for the graph
    for(let row of tbl){
        let source = row["SOURCE_SUBREDDIT"];
        let dest = row["TARGET_SUBREDDIT"];

        if(!(source in raw_data)){
            raw_data[source] = {
                id: source,
                name: source,
                value: 0,
                category: 'source',
                symbolSize: 0
            }
        }
        if(!(dest in raw_data)){
            raw_data[dest] = {
                id: dest,
                name: dest,
                value: 0,
                category: 'destination',
                symbolSize: 0
            }
        }

        // Increment values for each time a link occurs
        raw_data[source].value++;
        raw_data[source].symbolSize += 0.1;

        raw_data[dest].value++;
        raw_data[dest].symbolSize += 0.1;

        let keys = Object.keys(row);
        let values = Object.values(row);

        let avgs = {};

        let max = -Infinity;
        let top_sentiment = null;

        // Each link, calculate what average sentiment is highest
        // Prepare for average calculation here
        for(let i=0; i<keys.length; i++){
            if(keys[i].startsWith("LIWC_")){
                if(!(keys[i] in avgs)){
                    avgs[keys[i]] = [];
                }
                avgs[keys[i]].push(values[i])
            }
        }

        // Actually calculate the average here and update the max value if the average for this sentiment is larger than another
        for(let sent in avgs){
            let total = avgs[sent].reduce((a, b) => a + b, 0)
            if(avgs[sent].length > 0){
                let avg = total / avgs[sent].length;
                if(avg > max){
                    max = avg;
                    top_sentiment = sent
                }
            }
        }


        // Set the color of a link based on the largest average sentiment
        let color = "grey";
        if(top_sentiment != null){
            color = sentiment_colors[top_sentiment.replace("LIWC_", "").toLowerCase()]
        }

        // Push the link to the data structure
        links.push({
            source: source,
            target: dest,
            lineStyle: {
                color: color
            }
        });

    }

    // Push each node to the data structure
    for(let node in raw_data){
        let value = raw_data[node].value;
        if(value > 0){
            // Algorithm to calculate node size: s = 2 * log(v) + 2 where s is node size and v is value (number of links)
            raw_data[node].symbolSize = 2 * Math.log2(value) + 2
            data.push(raw_data[node])
        }

    }

    // Push the data structure to the graph
    let option = document.networkGraph.getOption();

    option.series[0].data = data;
    option.series[0].links = links;

    document.networkGraph.setOption(option);

}

// Trigger a select in the graph when called in an interaction event
function selectGraph(params){
    console.log(`Selecting ${params.data[0]}`)

    document.networkGraph.dispatchAction({
        action: "select",
        seriesIndex: 0,
        name: params.value[0]
    })

}

// Initialize the link chart
function createLinkBar(){
    // Create the base data structure
    document.linkChart = echarts.init(document.getElementById("link"))
    let option = {
        title: {
            text: "How is this node linked?",
            subtext: "Clink on a node to view its links"
        },
        yAxis: {
            type: "value"
        },
        xAxis: {
            type: "category",
            splitNumber: 1,
            axisLabel: {
                interval: 0,
                rotate: 90,
            },
            axisTick: {
                alignWithLabel: true
            }
        },
        legend: {
            data: ["Outgoing links", "Incoming links"]
        },
        tooltip: {
            show: true
        },
        series: [
            {
                type: "bar",
                name: "Outgoing links",
                data: [],
                stack: "sub"
            },
            {
                type: "bar",
                name: "Incoming links",
                data: [],
                stack: "sub"
            }
        ]
    };
    // Push base structure to chart instance
    document.linkChart.setOption(option);

    // Add events to chart
    document.linkChart.on("click", "series", updateSentimentBar);
    document.linkChart.on("click", "series", selectGraph);

    document.linkChart.on("mouseover", "series", function (params) {
        // When hovering over series, highlight the serie in the graph
        document.networkGraph.dispatchAction({
            type: "highlight",
            name: params.name
        })
    })
}

// Update the displayed links in the chart
function updateLinkBar(params){
    console.log(`Clicked on ${params.name}`);

    let baseSub = params.name;
    let subs = {};

    //Select which row contains the link we clicked as a source or destination
    for(let i=0; i<rows.length; i++){
        let link = {
            source: rows[i]["SOURCE_SUBREDDIT"],
            target: rows[i]["TARGET_SUBREDDIT"],
        };

        // Count how much a link has been made
        if(link.target === baseSub || link.source === baseSub){
            let sub = (link.target === baseSub) ? link.source:link.target;
            if(!(sub in subs)) {
                subs[sub] = {
                    outgoing: 0,
                    incoming: 0
                }
            }

            if(link.target === sub){
                // Outgoing link
                subs[sub].outgoing++;
            }
            else{
                // Incoming link
                subs[sub].incoming++;
            }
        }
    }

    // Get the base data structure
    let option = document.linkChart.getOption();

    // Change title of chart
    option.title[0].subtext = `Showing links for ${baseSub}`;

    // For each subreddit set the link count, direction and where the link is coming from/going too
    // Negative link count? => outgoing link | Positive link count? => incoming link
    let cat = [];
    let incoming = [];
    let outgoing = [];
    for(const sub in subs){
        cat.push(sub);
        let link = subs[sub];
        incoming.push([sub, link.incoming, baseSub]);
        outgoing.push([sub, link.outgoing * -1, baseSub]);
    }

    // Set data in the structure
    option.xAxis.data = cat;
    option.series[0].data = outgoing;
    option.series[1].data = incoming;

    // Push data structure to chart
    document.linkChart.setOption(option);
}

// Initialize sentiment chart
function createSentimentBar(){
    document.sentimentChart = echarts.init(document.getElementById("sentiment"))
    // Set base structure
    let option = {
        title: {
            text: "What is the sentiment between subs?",
            subtext: "Click on a link to show its sentiments"
        },
        yAxis: {
            type: "value"
        },
        xAxis: {
            type: "category",
            splitNumber: 1,
            interval: 0,
            axisLabel: {
                interval: 0,
                rotate: 90,
            },
            axisTick: {
                alignWithLabel: true
            }
        },
        legend: {
            show: true,
        },
        tooltip: {
            show: true
        },
        series: [
            {
                type: "bar",
                name: "Sentiment",
                data: [],
            }
        ]
    };
    document.sentimentChart.setOption(option);

    // Set interaction events for the sentiment chart
    document.sentimentChart.on('click', "series", updateGraph);
    document.sentimentChart.on("mouseover", "series", function (params) {
        // WHen hovering series in the sentiment chart, highlight it in the graph
        document.networkGraph.dispatchAction({
            type: "highlight",
            name: params.value[2][0]
        })
    })
}

// Updata data for the sentiment chart
function updateSentimentBar(params){
    let source = "";
    let target = "";

    // Get different values from different events, handle it here
    if(params.componentSubType === "graph"){
        // Click in the graph
        source = params.data.source;
        target = params.data.target;
    }
    else{
        // Click in the link chart
        if(params.value[1] < 0){
            // Link was outgoing
            source = params.value[2];
            target = params.value[0];
        }
        else{
            // Link was incoming
            source = params.value[0];
            target = params.value[2];
        }
    }

    console.log(`Showing sentiment from ${source} to ${target}`);

    let comb_data = {};

    // Get the sentiment for each of these exact links in the dataset
    for(let i=0; i<rows.length; i++){
        const row = rows[i];

        // Check if the is the exact link
        if (row["SOURCE_SUBREDDIT"] === source && row["TARGET_SUBREDDIT"] === target){
            // We can use this link
            // Only use LIWC columns
            let cols = Object.keys(row);
            for(let col of cols){
                if(col.startsWith("LIWC_")){
                    let fmt = col.replace("LIWC_", "")
                    if(!(fmt in comb_data)){
                        comb_data[fmt] = []
                    }
                    // Store the sentiment value in the sentiment object
                    comb_data[fmt].push(parseFloat(row[col]))
                }
            }

        }
    }

    let data = [];
    let cat = [];

    for(let sentiment in comb_data){
        // Calculate the average for each sentiment, data from array of all sentiment values for link, created above
        cat.push(sentiment);
        let sum = 0;
        for(let i=0; i<comb_data[sentiment].length; i++){
            sum += comb_data[sentiment][i];
        }

        let avg = sum / comb_data[sentiment].length
        // Push the calculated average for a sentiment to an array, already in the correct structure for the chart
        data.push({
            name: sentiment,
            value: [sentiment, avg, [source, target]],
            itemStyle: {
                color: sentiment_colors[sentiment.toLowerCase()]
            }
        })

        //data.push([sentiment, avg, [source, target]])
    }

    // Function to sort the series in chart from high to low, while keeping it prepared structure
    let compare = function(a, b){
        if(a.value[1] > b.value[1]) return -1;
        else if(a.value[1] < b.value[1]) return 1;
        else return 0;
    }

    // Perform the sort function
    data = data.sort(compare);

    // Get the base data structure
    let option = document.sentimentChart.getOption();

    // Update chart subtitle
    option.title[0].subtext = `Showing sentiment from ${source} to ${target}`;

    //Push data to chart
    option.series[0].data = data;
    option.xAxis.data = cat;
    document.sentimentChart.setOption(option);

}
</script>
</html>